# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml


variables:
  azureSubscription: MSDN_nicolasyuen
  deploymentEnabled: true
  destroyEnabled: false
  landingZoneName: "landingzone_caf_foundationsv2"
  environment: "MSDN_nicolasyuen"

resources:
  containers:
  - container: rover
    image: aztfmod/rover:2001.0622
    options: --user 0:0 -v /tmp:/tmp -e TF_PLUGIN_CACHE_DIR="/tmp/tf-plugin-cache" #temporary workaround as the user needs USERADD rights

stages:
- stage: Rover
  displayName: "Validating Terraform Code"
  jobs:
  - job: Validation
    pool:
      vmImage: 'ubuntu-latest'
    container: rover
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: ${{variables.azureSubscription}}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
            echo "Validating landing zone TF files"
            export TF_DATA_DIR="$(System.DefaultWorkingDirectory)" 
            /tf/rover/launchpad.sh $(System.DefaultWorkingDirectory)/$(landingZoneName) validate
      displayName: 'Rover validation'

- stage: Plan
  displayName: "Terraform Plan"
  jobs:
  - job: Plan
    pool:
      vmImage: 'ubuntu-latest'
    container: rover
    steps:
    - task: AzureCLI@2
      enabled: ${{variables.deploymentEnabled}}
      condition: succeeded()
      inputs:
        azureSubscription: ${{variables.azureSubscription}}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
            echo "Planning landing zone deployment"
            export TF_DATA_DIR="$(System.DefaultWorkingDirectory)" 
            /tf/rover/launchpad.sh $(Build.SourcesDirectory)/$(landingZoneName) plan -out $(Build.ArtifactStagingDirectory)/$(landingZoneName).tfplan
      displayName: 'Landing Zone Plan'
    - task: PublishBuildArtifacts@1
        inputs:
          pathtoPublish: '$(Build.ArtifactStagingDirectory)' 
          artifactName: 'tfplan' 
          publishLocation: 'Container' 

- stage: Apply
  displayName: "Terraform Apply"
  jobs:
  - job: Apply
    pool:
      vmImage: 'ubuntu-latest'
    container: rover
    steps:
    - task: AzureCLI@2
      enabled: ${{variables.deploymentEnabled}}
      condition: succeeded()
      inputs:
        azureSubscription: ${{variables.azureSubscription}}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
            echo "Planning landing zone deployment"
            export TF_DATA_DIR="$(System.DefaultWorkingDirectory)" 
            /tf/rover/launchpad.sh $(Build.SourcesDirectory)/$(landingZoneName) apply $(Build.ArtifactStagingDirectory)/$(landingZoneName).tfplan
      displayName: 'Landing Zone Plan'


- stage: Destroy
  displayName: "Terraform Destroy"
  condition: and(or(succeeded(), failed()), eq(variables['destroyEnabled'], true))
  jobs:
  - job: Destroy
    pool:
      vmImage: 'ubuntu-latest'
    container: rover
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: ${{variables.azureSubscription}}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
            echo "Applying landing zone deployment"
            export TF_DATA_DIR="$(System.DefaultWorkingDirectory)" 
            /tf/rover/launchpad.sh $(Build.SourcesDirectory)/$(landingZoneName) destroy
      displayName: 'Landing Zone Apply'
    - task: AzureCLI@2 #TODO <-- LEVERAGE the Azure Resource Graph to confirm, an option is to add the query / script alongside some test variable files to make it more generic"
      inputs:
        azureSubscription: ${{variables.azureSubscription}}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
            echo "Validating resources on Azure have been deleted" 
      displayName: 'Azure resources deletion validation'
